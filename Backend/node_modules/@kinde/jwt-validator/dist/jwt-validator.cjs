"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const K=crypto,$=e=>e instanceof CryptoKey,b=new TextEncoder,v=new TextDecoder;function B(...e){const t=e.reduce((a,{length:c})=>a+c,0),r=new Uint8Array(t);let n=0;for(const a of e)r.set(a,n),n+=a.length;return r}const z=e=>{const t=atob(e),r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t.charCodeAt(n);return r},R=e=>{let t=e;t instanceof Uint8Array&&(t=v.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return z(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}};class h extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(t){var r;super(t),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,(r=Error.captureStackTrace)==null||r.call(Error,this,this.constructor)}}class y extends h{static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}constructor(t,r="unspecified",n="unspecified"){super(t),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=r,this.reason=n}}class O extends h{static get code(){return"ERR_JWT_EXPIRED"}constructor(t,r="unspecified",n="unspecified"){super(t),this.code="ERR_JWT_EXPIRED",this.claim=r,this.reason=n}}class Y extends h{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class g extends h{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class u extends h{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class L extends h{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}class M extends h{constructor(){super(...arguments),this.code="ERR_JWKS_INVALID"}static get code(){return"ERR_JWKS_INVALID"}}class U extends h{constructor(){super(...arguments),this.code="ERR_JWKS_NO_MATCHING_KEY",this.message="no applicable key found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_NO_MATCHING_KEY"}}class X extends h{constructor(){super(...arguments),this.code="ERR_JWKS_MULTIPLE_MATCHING_KEYS",this.message="multiple matching keys found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_MULTIPLE_MATCHING_KEYS"}}class Q extends h{constructor(){super(...arguments),this.code="ERR_JWKS_TIMEOUT",this.message="request timed out"}static get code(){return"ERR_JWKS_TIMEOUT"}}class Z extends h{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}function S(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function A(e,t){return e.name===t}function W(e){return parseInt(e.name.slice(4),10)}function j(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}function ee(e,t){if(t.length&&!t.some(r=>e.usages.includes(r))){let r="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const n=t.pop();r+=`one of ${t.join(", ")}, or ${n}.`}else t.length===2?r+=`one of ${t[0]} or ${t[1]}.`:r+=`${t[0]}.`;throw new TypeError(r)}}function te(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!A(e.algorithm,"HMAC"))throw S("HMAC");const n=parseInt(t.slice(2),10);if(W(e.algorithm.hash)!==n)throw S(`SHA-${n}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!A(e.algorithm,"RSASSA-PKCS1-v1_5"))throw S("RSASSA-PKCS1-v1_5");const n=parseInt(t.slice(2),10);if(W(e.algorithm.hash)!==n)throw S(`SHA-${n}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!A(e.algorithm,"RSA-PSS"))throw S("RSA-PSS");const n=parseInt(t.slice(2),10);if(W(e.algorithm.hash)!==n)throw S(`SHA-${n}`,"algorithm.hash");break}case"EdDSA":{if(e.algorithm.name!=="Ed25519"&&e.algorithm.name!=="Ed448")throw S("Ed25519 or Ed448");break}case"ES256":case"ES384":case"ES512":{if(!A(e.algorithm,"ECDSA"))throw S("ECDSA");const n=j(t);if(e.algorithm.namedCurve!==n)throw S(n,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}ee(e,r)}function k(e,t,...r){var n;if(r.length>2){const a=r.pop();e+=`one of type ${r.join(", ")}, or ${a}.`}else r.length===2?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return t==null?e+=` Received ${t}`:typeof t=="function"&&t.name?e+=` Received function ${t.name}`:typeof t=="object"&&t!=null&&(n=t.constructor)!=null&&n.name&&(e+=` Received an instance of ${t.constructor.name}`),e}const I=(e,...t)=>k("Key must be ",e,...t);function F(e,t,...r){return k(`Key for the ${e} algorithm must be `,t,...r)}const V=e=>$(e),p=["CryptoKey"],re=(...e)=>{const t=e.filter(Boolean);if(t.length===0||t.length===1)return!0;let r;for(const n of t){const a=Object.keys(n);if(!r||r.size===0){r=new Set(a);continue}for(const c of a){if(r.has(c))return!1;r.add(c)}}return!0};function ne(e){return typeof e=="object"&&e!==null}function E(e){if(!ne(e)||Object.prototype.toString.call(e)!=="[object Object]")return!1;if(Object.getPrototypeOf(e)===null)return!0;let t=e;for(;Object.getPrototypeOf(t)!==null;)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}const ae=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if(typeof r!="number"||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};function ie(e){let t,r;switch(e.kty){case"RSA":{switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new g('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"EC":{switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new g('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"OKP":{switch(e.alg){case"EdDSA":t={name:e.crv},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new g('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}default:throw new g('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}const se=async e=>{if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:t,keyUsages:r}=ie(e),n=[t,e.ext??!1,e.key_ops??r],a={...e};return delete a.alg,delete a.use,K.subtle.importKey("jwk",a,...n)};async function oe(e,t){if(!E(e))throw new TypeError("JWK must be an object");switch(t||(t=e.alg),e.kty){case"oct":if(typeof e.k!="string"||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return R(e.k);case"RSA":if(e.oth!==void 0)throw new g('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return se({...e,alg:t});default:throw new g('Unsupported "kty" (Key Type) Parameter value')}}const ce=(e,t)=>{if(!(t instanceof Uint8Array)){if(!V(t))throw new TypeError(F(e,t,...p,"Uint8Array"));if(t.type!=="secret")throw new TypeError(`${p.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}},de=(e,t,r)=>{if(!V(t))throw new TypeError(F(e,t,...p));if(t.type==="secret")throw new TypeError(`${p.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if(r==="sign"&&t.type==="public")throw new TypeError(`${p.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if(r==="decrypt"&&t.type==="public")throw new TypeError(`${p.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(t.algorithm&&r==="verify"&&t.type==="private")throw new TypeError(`${p.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&r==="encrypt"&&t.type==="private")throw new TypeError(`${p.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)},ue=(e,t,r)=>{e.startsWith("HS")||e==="dir"||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e)?ce(e,t):de(e,t,r)};function fe(e,t,r,n,a){if(a.crit!==void 0&&(n==null?void 0:n.crit)===void 0)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||n.crit===void 0)return new Set;if(!Array.isArray(n.crit)||n.crit.length===0||n.crit.some(i=>typeof i!="string"||i.length===0))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let c;r!==void 0?c=new Map([...Object.entries(r),...t.entries()]):c=t;for(const i of n.crit){if(!c.has(i))throw new g(`Extension Header Parameter "${i}" is not recognized`);if(a[i]===void 0)throw new e(`Extension Header Parameter "${i}" is missing`);if(c.get(i)&&n[i]===void 0)throw new e(`Extension Header Parameter "${i}" MUST be integrity protected`)}return new Set(n.crit)}const he=(e,t)=>{if(t!==void 0&&(!Array.isArray(t)||t.some(r=>typeof r!="string")))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};function le(e,t){const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"EdDSA":return{name:t.name};default:throw new g(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}function me(e,t,r){if($(t))return te(t,e,r),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(I(t,...p));return K.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[r])}throw new TypeError(I(t,...p,"Uint8Array"))}const ye=async(e,t,r,n)=>{const a=await me(e,t,"verify");ae(e,a);const c=le(e,a.algorithm);try{return await K.subtle.verify(c,a,r,n)}catch{return!1}};async function pe(e,t,r){if(!E(e))throw new u("Flattened JWS must be an object");if(e.protected===void 0&&e.header===void 0)throw new u('Flattened JWS must have either of the "protected" or "header" members');if(e.protected!==void 0&&typeof e.protected!="string")throw new u("JWS Protected Header incorrect type");if(e.payload===void 0)throw new u("JWS Payload missing");if(typeof e.signature!="string")throw new u("JWS Signature missing or incorrect type");if(e.header!==void 0&&!E(e.header))throw new u("JWS Unprotected Header incorrect type");let n={};if(e.protected)try{const T=R(e.protected);n=JSON.parse(v.decode(T))}catch{throw new u("JWS Protected Header is invalid")}if(!re(n,e.header))throw new u("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const a={...n,...e.header},c=fe(u,new Map([["b64",!0]]),r==null?void 0:r.crit,n,a);let i=!0;if(c.has("b64")&&(i=n.b64,typeof i!="boolean"))throw new u('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:d}=a;if(typeof d!="string"||!d)throw new u('JWS "alg" (Algorithm) Header Parameter missing or invalid');const f=r&&he("algorithms",r.algorithms);if(f&&!f.has(d))throw new Y('"alg" (Algorithm) Header Parameter value not allowed');if(i){if(typeof e.payload!="string")throw new u("JWS Payload must be a string")}else if(typeof e.payload!="string"&&!(e.payload instanceof Uint8Array))throw new u("JWS Payload must be a string or an Uint8Array instance");let s=!1;typeof t=="function"&&(t=await t(n,e),s=!0),ue(d,t,"verify");const o=B(b.encode(e.protected??""),b.encode("."),typeof e.payload=="string"?b.encode(e.payload):e.payload);let l;try{l=R(e.signature)}catch{throw new u("Failed to base64url decode the signature")}if(!await ye(d,t,l,o))throw new Z;let w;if(i)try{w=R(e.payload)}catch{throw new u("Failed to base64url decode the payload")}else typeof e.payload=="string"?w=b.encode(e.payload):w=e.payload;const m={payload:w};return e.protected!==void 0&&(m.protectedHeader=n),e.header!==void 0&&(m.unprotectedHeader=e.header),s?{...m,key:t}:m}async function Se(e,t,r){if(e instanceof Uint8Array&&(e=v.decode(e)),typeof e!="string")throw new u("Compact JWS must be a string or Uint8Array");const{0:n,1:a,2:c,length:i}=e.split(".");if(i!==3)throw new u("Invalid Compact JWS");const d=await pe({payload:a,protected:n,signature:c},t,r),f={payload:d.payload,protectedHeader:d.protectedHeader};return typeof t=="function"?{...f,key:d.key}:f}const ge=e=>Math.floor(e.getTime()/1e3),G=60,q=G*60,P=q*24,we=P*7,Ee=P*365.25,be=/^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i,D=e=>{const t=be.exec(e);if(!t||t[4]&&t[1])throw new TypeError("Invalid time period format");const r=parseFloat(t[2]),n=t[3].toLowerCase();let a;switch(n){case"sec":case"secs":case"second":case"seconds":case"s":a=Math.round(r);break;case"minute":case"minutes":case"min":case"mins":case"m":a=Math.round(r*G);break;case"hour":case"hours":case"hr":case"hrs":case"h":a=Math.round(r*q);break;case"day":case"days":case"d":a=Math.round(r*P);break;case"week":case"weeks":case"w":a=Math.round(r*we);break;default:a=Math.round(r*Ee);break}return t[1]==="-"||t[4]==="ago"?-a:a},N=e=>e.toLowerCase().replace(/^application\//,""),Ae=(e,t)=>typeof e=="string"?t.includes(e):Array.isArray(e)?t.some(Set.prototype.has.bind(new Set(e))):!1,_e=(e,t,r={})=>{const{typ:n}=r;if(n&&(typeof e.typ!="string"||N(e.typ)!==N(n)))throw new y('unexpected "typ" JWT header value',"typ","check_failed");let a;try{a=JSON.parse(v.decode(t))}catch{}if(!E(a))throw new L("JWT Claims Set must be a top-level JSON object");const{requiredClaims:c=[],issuer:i,subject:d,audience:f,maxTokenAge:s}=r,o=[...c];s!==void 0&&o.push("iat"),f!==void 0&&o.push("aud"),d!==void 0&&o.push("sub"),i!==void 0&&o.push("iss");for(const m of new Set(o.reverse()))if(!(m in a))throw new y(`missing required "${m}" claim`,m,"missing");if(i&&!(Array.isArray(i)?i:[i]).includes(a.iss))throw new y('unexpected "iss" claim value',"iss","check_failed");if(d&&a.sub!==d)throw new y('unexpected "sub" claim value',"sub","check_failed");if(f&&!Ae(a.aud,typeof f=="string"?[f]:f))throw new y('unexpected "aud" claim value',"aud","check_failed");let l;switch(typeof r.clockTolerance){case"string":l=D(r.clockTolerance);break;case"number":l=r.clockTolerance;break;case"undefined":l=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:C}=r,w=ge(C||new Date);if((a.iat!==void 0||s)&&typeof a.iat!="number")throw new y('"iat" claim must be a number',"iat","invalid");if(a.nbf!==void 0){if(typeof a.nbf!="number")throw new y('"nbf" claim must be a number',"nbf","invalid");if(a.nbf>w+l)throw new y('"nbf" claim timestamp check failed',"nbf","check_failed")}if(a.exp!==void 0){if(typeof a.exp!="number")throw new y('"exp" claim must be a number',"exp","invalid");if(a.exp<=w-l)throw new O('"exp" claim timestamp check failed',"exp","check_failed")}if(s){const m=w-a.iat,T=typeof s=="number"?s:D(s);if(m-l>T)throw new O('"iat" claim timestamp check failed (too far in the past)',"iat","check_failed");if(m<0-l)throw new y('"iat" claim timestamp check failed (it should be in the past)',"iat","check_failed")}return a};async function Re(e,t,r){var i;const n=await Se(e,t,r);if((i=n.protectedHeader.crit)!=null&&i.includes("b64")&&n.protectedHeader.b64===!1)throw new L("JWTs MUST NOT use unencoded payload");const c={payload:_e(n.protectedHeader,n.payload,r),protectedHeader:n.protectedHeader};return typeof t=="function"?{...c,key:n.key}:c}function ve(e){switch(typeof e=="string"&&e.slice(0,2)){case"RS":case"PS":return"RSA";case"ES":return"EC";case"Ed":return"OKP";default:throw new g('Unsupported "alg" value for a JSON Web Key Set')}}function Te(e){return e&&typeof e=="object"&&Array.isArray(e.keys)&&e.keys.every(We)}function We(e){return E(e)}function Je(e){return typeof structuredClone=="function"?structuredClone(e):JSON.parse(JSON.stringify(e))}class Ke{constructor(t){if(this._cached=new WeakMap,!Te(t))throw new M("JSON Web Key Set malformed");this._jwks=Je(t)}async getKey(t,r){const{alg:n,kid:a}={...t,...r==null?void 0:r.header},c=ve(n),i=this._jwks.keys.filter(s=>{let o=c===s.kty;if(o&&typeof a=="string"&&(o=a===s.kid),o&&typeof s.alg=="string"&&(o=n===s.alg),o&&typeof s.use=="string"&&(o=s.use==="sig"),o&&Array.isArray(s.key_ops)&&(o=s.key_ops.includes("verify")),o&&n==="EdDSA"&&(o=s.crv==="Ed25519"||s.crv==="Ed448"),o)switch(n){case"ES256":o=s.crv==="P-256";break;case"ES256K":o=s.crv==="secp256k1";break;case"ES384":o=s.crv==="P-384";break;case"ES512":o=s.crv==="P-521";break}return o}),{0:d,length:f}=i;if(f===0)throw new U;if(f!==1){const s=new X,{_cached:o}=this;throw s[Symbol.asyncIterator]=async function*(){for(const l of i)try{yield await H(o,l,n)}catch{}},s}return H(this._cached,d,n)}}async function H(e,t,r){const n=e.get(t)||e.set(t,{}).get(t);if(n[r]===void 0){const a=await oe({...t,ext:!0},r);if(a instanceof Uint8Array||a.type!=="public")throw new M("JSON Web Key Set members must be public keys");n[r]=a}return n[r]}function Pe(e){const t=new Ke(e);return async(r,n)=>t.getKey(r,n)}const Ce=async(e,t,r)=>{let n,a,c=!1;typeof AbortController=="function"&&(n=new AbortController,a=setTimeout(()=>{c=!0,n.abort()},t));const i=await fetch(e.href,{signal:n?n.signal:void 0,redirect:"manual",headers:r.headers}).catch(d=>{throw c?new Q:d});if(a!==void 0&&clearTimeout(a),i.status!==200)throw new h("Expected 200 OK from the JSON Web Key Set HTTP response");try{return await i.json()}catch{throw new h("Failed to parse the JSON Web Key Set HTTP response as JSON")}};function Oe(){return typeof WebSocketPair<"u"||typeof navigator<"u"&&navigator.userAgent==="Cloudflare-Workers"||typeof EdgeRuntime<"u"&&EdgeRuntime==="vercel"}let J;var _,x;(typeof navigator>"u"||!((x=(_=navigator.userAgent)==null?void 0:_.startsWith)!=null&&x.call(_,"Mozilla/5.0 ")))&&(J="jose/v5.2.4");class Ie{constructor(t,r){if(!(t instanceof URL))throw new TypeError("url must be an instance of URL");this._url=new URL(t.href),this._options={agent:r==null?void 0:r.agent,headers:r==null?void 0:r.headers},this._timeoutDuration=typeof(r==null?void 0:r.timeoutDuration)=="number"?r==null?void 0:r.timeoutDuration:5e3,this._cooldownDuration=typeof(r==null?void 0:r.cooldownDuration)=="number"?r==null?void 0:r.cooldownDuration:3e4,this._cacheMaxAge=typeof(r==null?void 0:r.cacheMaxAge)=="number"?r==null?void 0:r.cacheMaxAge:6e5}coolingDown(){return typeof this._jwksTimestamp=="number"?Date.now()<this._jwksTimestamp+this._cooldownDuration:!1}fresh(){return typeof this._jwksTimestamp=="number"?Date.now()<this._jwksTimestamp+this._cacheMaxAge:!1}async getKey(t,r){(!this._local||!this.fresh())&&await this.reload();try{return await this._local(t,r)}catch(n){if(n instanceof U&&this.coolingDown()===!1)return await this.reload(),this._local(t,r);throw n}}async reload(){this._pendingFetch&&Oe()&&(this._pendingFetch=void 0);const t=new Headers(this._options.headers);J&&!t.has("User-Agent")&&(t.set("User-Agent",J),this._options.headers=Object.fromEntries(t.entries())),this._pendingFetch||(this._pendingFetch=Ce(this._url,this._timeoutDuration,this._options).then(r=>{this._local=Pe(r),this._jwksTimestamp=Date.now(),this._pendingFetch=void 0}).catch(r=>{throw this._pendingFetch=void 0,r})),await this._pendingFetch}}function De(e,t){const r=new Ie(e,t);return async(n,a)=>r.getKey(n,a)}async function Ne(e,t){const r=De(new URL(`${t}/.well-known/jwks.json`));try{return await Re(e,r),{valid:!0,message:"Token is valid"}}catch(n){return{valid:!1,message:n instanceof Error?n.message:"Unknown Error"}}}const He=async e=>e.token?e.domain?await Ne(e.token,e.domain):{valid:!1,message:"Domain is required"}:{valid:!1,message:"Token is required"};exports.validateToken=He;
